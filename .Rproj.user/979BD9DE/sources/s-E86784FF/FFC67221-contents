this is not a comment, will produce an error
# this is a comment - use me extensively to take notes!

## Simple math
5

5 + 2
5 - 2
5 * 2
5 / 2

5 %/% 2  # integer division - see, you can use comments AFTER commands as well!
5 %% 2  # module

5 ^ 2  # power
exp(2)  # e ^ 2
sqrt(4)
log(8, 2)  # argument, base

abs(-5)  # absolute value

# rounding
round(3.4)  # 3
round(3.7)  # 4
floor(3.7)  # 3
ceiling(3.4)  # 4
round(5.42552, digits=2)  # 5.43

# remember to save this R file every now and then!

## Variables
a
a <- 3384917922  # note that assignment is <- symbol
a
test = 3454  # = also works in this example, but strongly discouraged (trust me on this)
test
a
A  # This won't work: R is case-sensitive!
a + 2
a + 5
b <- 56 + (67 / 12) * sqrt(7)  # use parentheses to do the math right!
b
b <- b + a
b
a

## Vectors (unidimensional arrays where each element has the same mode)
my.num.vector <- c(1, 5, 8, 10)  # c = combine, used to make vectors
my.num.vector  # work faster: use TAB to autocomplete, or the arrow keys!
my.seq.vector <- 5:26  # from 5 to 26
my.seq.vector
rev(my.seq.vector)  # reverse order
26:5  # this also works
my.empty.vector <- vector(mode="numeric", length=10)
my.empty.vector
my.scalar <- 1  # scalars are one-element vectors

# work on specific elements of vectors
my.num.vector
my.num.vector[3]  # third element - note the square brackets!
my.num.vector[2:4]  # second to fourth element
my.num.vector[1, 3]  # this doesn't work - why?
my.num.vector[c(1, 3)]  # first and third element - this works!
my.num.vector[c(-1, -3)]  # everything except first and third element
my.num.vector  # original vector is unchanged
my.small.vector <- my.num.vector[2:4]  # can save what I extract into another vector
my.num.vector[2] <- 7  # not only extract, you can also EDIT specific elements!
my.num.vector
my.small.vector
my.small.vector <- c(my.small.vector, 7)  # add an extra element at the end of your vector
my.small.vector
my.small.vector[5:6] <- c(12, 14)  # this is another way. Note that many languages would give an error for something like this, but not R
my.small.vector

# functions to automatically generate lists of numbers
seq(-30, 30, by = 2)  # all even numbers from -30 to 30
seq(-30, 30, length.out=10)  # 10 numbers evenly spaced between -30 to 30
rep(c(1, 2, 3, 4), times=6)  # repeat the sequence 1 2 3 4 six times
rep(c(1, 2, 3, 4), each=6)  # repeat 1 six times, then 2 six times, etc

# associate names to vector elements
my.num.vector
names(my.num.vector)  # names is a vector itself!
names(my.num.vector) <- c("1st #", "2nd #", "3rd #", "4th #")  # note the double quotes - we are providing characters, not numbers!
names(my.num.vector)
names(my.num.vector)[3]  # if names is a vector, I can extract elements!
names(my.num.vector[3])  # this is an alternative
my.num.vector

length(my.num.vector)

max(my.num.vector)
min(my.num.vector)

which.max(my.num.vector)  # rather than the max value, get the position of the max value
which.min(my.num.vector)  # same for min

sum(my.num.vector)

## Matrices (two-dimension arrays where each element has the same mode)

my.matrix <- matrix(nrow=2, ncol=3)
my.matrix  # this is empty! (more precisely, filled in with NAs)

my.matrix[2, 3]  # element at second row, third column (ALWAYS: row, column)
my.matrix[2, 3] <- 5
my.matrix  # not empty anymore

my.matrix[2, ]  # entire second row - note, result is a vector
my.matrix[2, ][3]  # so I can ask the third element of the second row
my.matrix[2, 3]  # equivalent, more straightforward way (again: row, column)

my.matrix[, 3]  # entire third column
my.matrix[2, c(2, 3)]  # second row, and last two columns

dim(my.matrix)  # result is number of rows and number of columns
nrow(my.matrix)
ncol(my.matrix)

rownames(my.matrix)  # empty
rownames(my.matrix) <- c("first row", "second row")
rownames(my.matrix)
colnames(my.matrix)
colnames(my.matrix) <- c("first column", "second column")  # error! why?
ncol(my.matrix)
colnames(my.matrix) <- c("first column", "second column", "third column")
colnames(my.matrix)
colnames(my.matrix)[2]

# build matrices by binding rows or columns
x <- 1:3
y <- 10:12
x
y

my.row.matrix <- rbind(x, y)  # rbind = row binding
my.row.matrix

my.col.matrix <- cbind(x, y)  # cbind = column binding
my.col.matrix

# build matrices by providing elements from a vector
my.matrix <- matrix(c(1, 3, 5, 6:8), ncol=3, byrow=TRUE)  # 6-element vector, 3 columns, how many rows? Necessarily 2! And we fill matrix by row (default is by column)
my.matrix
t(my.matrix)  # transpose (swaps rows and columns)

## Arrays (n-dimension arrays where each elements has the same mode)
z <- array(1:24, dim=c(2, 3, 4))  # 24-element vector, and array is 2 by 3 by 4
z

## Atomic classes
my.num.vector <- c(1, 5, 8, 10)  # data type numeric (real number)
my.str.vector <- c("my", "dear", "friend")  # data type character
my.log.vector <- c(TRUE, FALSE, FALSE, T, F)  # data type logical. Notice that T=TRUE and F=FALSE
my.log.vector
my.log.vector <- c(true, FALSE)  # this won't work - why?
my.log.vector  # so my.log.vector is unchanged
my.int.vector <- c(1L, 450L)  # data type integer (discrete) - not frequently used

my.unknown.vector <- c("a", 4, TRUE)  # what if you mix and match? Elements coerced to data type that makes most sense
my.unknown.vector

# ask vector class
class(my.unknown.vector)  # tells you it's a character vector!
class(my.str.vector)
class(my.int.vector)

# ask for a specific type
is.numeric(my.num.vector)
is.character(my.num.vector)
is.character(my.str.vector)

# optional
# is.logical(x)
# is.integer(x)

# convert from a type to another
once.num <- as.character(my.num.vector)
my.num.vector
once.num  # notice the double quotes in the output
class(my.num.vector)
class(once.num)

as.numeric(my.str.vector)  # cannot do impossible things!
as.numeric(once.num)  # this works because it makes sense

# optional
# as.logical(x)
# as.integer(x)
# as.complex(x)

## Vectorized operations - Faster for you to write, and faster for R to execute
my.matrix
my.matrix + 1  # matrix and scalar: no need to write the same addition six times for each of the matrix elements
my.matrix * 2
my.matrix + my.matrix[1, ]  # things may not always work out as expected. Be careful!
my.matrix * my.matrix  # element-wise multiplication
x <- 1:4; y <- c(1, 6)  # two commands on the same line with semicolon
x * y  # element-wise multiplication returns 1*1, 2*6, 3*1, 4*6 (recycles the second vector) - note there is no error! Careful!!!!

# optional: true inner matrix multiplication
# my.matrix %*% my.matrix  # true inner matrix multiplication - does not work (incompatible dimensions)
# my.matrix %*% t(my.matrix)  # this works because ncol of 1st matrix = nrow of 2nd matrix. 1,1 element: 1*1 + 3*3 + 5*5; 1,2 element: 1*6 + 3*7 + 5*8; and so on

## Boolean operations
x < 3
less3 <- x < 3
less3  # notice that result is a logical vector
less3[4]
(x < 3)[4]  # this works as well, if you didn't want to assign to a variable
x == 2  # notice the double equal sign to distinguish from assignments
which(x == 2)  # converts boolean to index - in other words, tell you the position of what is true!
sum(x < 3)  # counts how many elements of x are less than 3; looks weird, but it makes sense if you think that FALSE = 0 and TRUE = 1
4 != 5  # are 4 and 5 different?
4 %in% x  # is 4 in x?
c(2, 8) %in% x  # are those two numbers in x?
match(c(2, 8), x)  # but where are 2 and 8 in x?
any(x > 4)
all(x < 2)

# And, Or, Not

3 > 2 & 5 < 4  # And - TRUE if all are TRUE
3 > 2 | 5 < 4  # Or - TRUE if any is TRUE
!(4 != 5)  # Not - this results in F
x < 4 & x > 2

# filter data using logical operations
x
less3
x[3]  # remember this?
which(less3)  # well, this is a vector as well, with positions
all.equal(which(less3), c(1, 2))  # proved!
x[which(less3)]  # so does this work? Shows only TRUE elements!
x[less3]  # this works too! Rather than providings indeces, I provide a vector of TRUE/FALSE and subset only elements matching TRUEs!
sum(x[x > 2])  # so now I can do math on subsets

## Data Frames (two-dimension data structures where each column may have a different mode = TABLES)
patient.id <- c(10, 20, 30)
age <- c(25, 34, 28)
diabetes <- c("T1", "T2", "T1")
status <- c("Poor", "Improved", "Excellent")
patient.data <- data.frame(patient.id, age, diabetes, status)

nrow(patient.data)
ncol(patient.data)
dim(patient.data)  # rows and columns

patient.data[1:2]  # 1st and 2nd columns
patient.data[c("diabetes", "status")]  # select columns by name
patient.data$age  # dollar sign convenient way to select columns - no double quotes! output returned as a vector
patient.data[patient.data$age == 28]  # not the right output! why?
patient.data[patient.data$age == 28, ]  # this works! We needed to tell which columns to retain (in this example, all of them)
patient.data[patient.data$age == 28, 3]  # filter both rows and columns
subset(patient.data, subset=age > 1 & age < 30, select = -status)

names(patient.data)
colnames(patient.data)
rownames(patient.data)
colnames(patient.data)[c(1, 3)] <- c("ID", "type")
patient.data

patient.data$new.var <- rep(0, nrow(patient.data))  # assigning an unknown column will create it
patient.data
patient.data <- cbind(patient.data, second.var=rep(0, nrow(patient.data)))  # you can also add a column by binding it

patient2 <- patient.data  # what about adding new rows? Less easy. Let's start
patient2$ID <- c(15, 78, 40)
patient2
patient.data <- rbind(patient.data, patient2)  # the two data frames must have the same structure!
patient.data
patient3 <- patient2
colnames(patient3)[3] <- "test"
patient3
rbind(patient.data, patient3)  # doesn't work (mismatch column names)

# sorting
patient.data  # notice not sorted by IDs
patient.data[c(1, 4, 2, 3, 6, 5), ]  # I can sort manually this way. Not ideal if I have a lot of data!
patient.data$ID  # this is a vector, right?
order(patient.data$ID)  # notice! Identical to the order I gave manually
patient.data[order(patient.data$ID), ]  # nice!

rank(patient.data$ID)  # who can tell the difference between order and rank? Look at the output!
sort(patient.data$ID)  # useful only to sort vectors

# head and tail of a dataset
data(iris)  # example dataset pre-built into R
iris
head(iris)  # top 6 rows
tail(iris)  # bottom 6 rows
head(iris, 10)  # top 10 rows

# get info on object - VERY useful
class(iris)
summary(iris)
str(iris)

# convert data frame to matrix
as.matrix(iris)
data.matrix(iris)  # can you tell me what the difference is?
str(as.matrix(iris))
str(data.matrix(iris))

# tomorrow: loading and saving data frames from/to text files!

## Missing values

v <- c(2, 6, 10, NA, 3)
sum(v)  # this doesn't work. why?
sum(v, na.rm=T)  # if you remove missing values, it works
is.na(v)  # which elements are NAs?
any(is.na(v))
v[is.na(v)] <- 0  # you can impute a value (that makes sense) in missing cells
v
sum(v)  # now it works

## Session: objects, saving
ls()  # all the objects we created today
rm(x)  # delete one object
ls()
rm(list=c("y", "a"))  # delete many objects - notice that the list of objects is provided as a character vector
ls()

save.image("day1.RData")  # I don't want to lose the data I have generated so far

# optional
# save(my.matrix, file="matrix.RData")  # this saves selected objects

savehistory()  # save history of commands. Note that there is no dot in between save and history, unlike save.image - these are the inconsistencies that make the language ugly sometimes

q()  # quit R

# this is the last line for today. Look, you have an R file with all your commands and comments. You can re-execute them easily, any time you want now! Awesome!